\chapter{Fundamentals -- Review++}
%%
%%
%%
\section{Import a basic Mule project into Anypoint Studio}
%%%%%%
\subsection{Import the starter project}
\begin{enumerate}
\item Start Anypoint Studio
\item Create a new workspace
\item Import the \ttt{apdw2-flights-starter.jar} project under the \ttt{studentFiles/mod01}
\end{enumerate}
%%%%%%
\subsection{Create new project}
\begin{enumerate}[resume*]
\item Create a new project
  \newline
  \emph{
    Creating a new project and copying only the files you minimally need for the class helps in containing the ``noise'' that is introduced with the starter project.  Additionally, there is the extra benefit of not having to deal with students who are having compilation issues with the starter project.
  }
\item Create a new project and call it dataweave
\item From the apdw2-flights-starter copy the following files over to the new project:
  \begin{enumerate}
  \item \ttt{src/main/resources/airportInfoTiny.csv} to \ttt{src/main/resources}
  \item \ttt{src/main/resources/examples/mockdata/deltaSoapResponsesToAllDestinations.xml} to \ttt{src/test/resources}
  \item \ttt{src/test/resources/flight-example.json} to \ttt{src/test/resources}
  \end{enumerate}
\end{enumerate}

%%
%%
%%
\section{Fundamentals review++}
\emph{
  In this WT the goal is to attempt (I am saying attempt because often enough we have participants who don’t meet the prerequisites) to bring everyone at the same level by (1) reviewing fundamentals and (2) illustrating features of DW that we will be using throughout the class
}

%%%%%%
\subsection{Create the flow, set the metadata}
\begin{enumerate}
\item Rename the \ttt{dataweave.xml} to \ttt{mod1.xml}
\item Create a new flow named \ttt{mod1-review++}
  \newline
  \emph{
    The reason for prefixing the flow name with the name of the flow is a best-practice one.
    Such a convention will improve the readability of your flows by identifying the
    Mule Configuration file a flow is defined under by just looking at a Flow Reference's
    display name.
  }
\item Drop a DW (aka \ttt{Transform Message}) to the process area of the flow
\item Define the payload input metadata to the \ttt{src/test/resources/flight-example.json},
  set the name of the type to \ttt{flight\_json}
\item Edit the sample data
\item Turn on the preview
\item Change the output to JSON
\end{enumerate}

%%%%%%
\subsection{Construction}
\begin{enumerate}[resume*]
\item What are the semantics of \ttt{\{\}} in DW?
  \begin{enumerate}
  \item Object creation
  \end{enumerate}
\item What are the semantics of \ttt{[]} in DW?
  \begin{enumerate}
  \item Array creation
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{Fields}
\begin{enumerate}[resume*]
\item Three different ways of accessing the field \ttt{airline}
  out of the \ttt{payload}. What are they?
  \begin{enumerate}
  \item \ttt{payload.airline}
  \item \ttt{payload["airline"]}
  \item \ttt{payload[0]}
  \end{enumerate}
  \emph{Let me let you in a secret: Objects internally are represented as arrays—field access is a façade}
\item Why DW stores objects as arrays?
  \begin{enumerate}
  \item Because DW is the only language I know of that allows the creation of objects with
    duplicate field names...
    \begin{lstlisting}
      {
        a: 1,
        a: 2,
        a: 3
      }
    \end{lstlisting}
    ... and the only way I can access the second and third field is through an index access.
    But now we have more questions that need to be answered.
  \item Why would a language allow for such a feature?  That is duplicate fields within an object.
    Because of XML, how else you expect to be able to generate XML with tags that repeat:
    \begin{lstlisting}
      %dw 2.0
      output application/xml
      ---
      "as": {
	a: 1,
	a: 2,
	a: 3
      }        
    \end{lstlisting}
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{String concatenation}
\begin{enumerate}[resume*]
\item Two ways to concatenate strings
  \begin{enumerate}
  \item \ttt{"The flight is operated by " ++ payload.airline}
  \item \ttt{"The flight is operated by \$\{payload.airline\}"}
  \end{enumerate}
\item You have to be careful that the expression inside the \ttt{\$\{\}} returns
  a string, otherwise you will be getting type missmatch errors.
\end{enumerate}

%%%%%%
\subsection{Conditional expressions}
\begin{enumerate}[resume*]
\item \ttt{if then else} conditional
  \begin{enumerate}
  \item \ttt{if (true) 1 else 0}
  \item \ttt{if (false) 1 else 0}
  \end{enumerate}
\item Nullity conditional
  \begin{enumerate}
  \item \lstinline{null default "Other value"}
  \item \lstinline{"The value" default "Other value"}
  \end{enumerate}
\item Conditional elements
  \begin{enumerate}
  \item Objects
    \begin{lstlisting}
      {
        a: 1,
        (b: 2) if (true),
        (c: 3) if (false)
      }
    \end{lstlisting}
  \item Arrays
    \begin{lstlisting}
      [
        1, 
        (2) if (true),
        (3) if (false)
      ]
    \end{lstlisting}
  \end{enumerate}
\end{enumerate}
%%%%%%
\subsection{Array access and Ranges}
\begin{enumerate}[resume*]
\item Array access
  \begin{enumerate}
  \item \ttt{[2,6,4,1,7][0]} evaluates to \ttt{2}
  \item \ttt{[2,6,4,1,7][-1]} evaluates to \ttt{7}
  \end{enumerate}
\item Ranges
  \begin{enumerate}
  \item \ttt{0 to 5} evaluates to the \ttt{[0,1,2,3,4,5]} array 
  \item \ttt{5 to 0} evaluates to the \ttt{[5,4,3,2,1,0]} array
  \end{enumerate}
\item Ranges, Arrays, and Strings
  \begin{enumerate}
  \item \ttt{[2,6,4,1,7][1 to -2]} evaluates to the \ttt{[6,4,1,7]} sub-array
  \item \ttt{[2,6,4,1,7][-1 to 0} reverses the array
  \item \ttt{payload.airline[-3 to -1]} evaluates to the last characters in the string
  \item \ttt{payload.airline[-1 to 0]} reverses the string
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{Common functions}
\begin{enumerate}[resume*]

\item \ttt{typeOf}
  \newline
  \emph{
    This is a great function for debugging--again and it will help us identify the types of
    data we are working with.  We will use it a few times to gain clarity when all else has
    failed.
  }
  \begin{enumerate}
    \item \ttt{typeOf([])}
    \item \ttt{typeOf({})}
  \end{enumerate}
  
\item \ttt{sizeOf}
  \begin{enumerate}
  \item \ttt{sizeOf({})}
  \item \ttt{sizeOf({a: 1})}
  \item \ttt{sizeOf(0 to 100)}
  \item \ttt{sizeOf("ABC")}
  \end{enumerate}

\item \ttt{contains}
  \begin{enumerate}
  \item \ttt{[2,6,4] contains 2}
  \item \ttt{"ABCD" contains "BC"}
  \end{enumerate}

\item \ttt{is}
  \begin{enumerate}
  \item \ttt{{} is Object}
  \item \ttt{[] is Array}  
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{Expression chaining}
\begin{enumerate}[resume*]
\item Create an array of integers
  \begin{enumerate}
  \item Do you know what expression chaining is?
    \begin{enumerate}
    \item \ttt{[2,5,3,7,8] map $+1 map $-1}
    \end{enumerate}
  \item We learned all about expression chains in elementary math!
    \begin{enumerate}
    \item \ttt{1 + 2 - 3}
    \end{enumerate}
  \end{enumerate}
\item This is a good opportunity to briefly talk about the \ttt{map} function
  \begin{enumerate}
  \item Do you know what the \ttt{map} semantics are?
    \begin{enumerate}
    \item \ttt{map} is a function
    \item \ttt{map} is invoked using infix notation
    \item \ttt{map} takes two argments and evaluates to a value
      \begin{enumerate}
      \item Left: an array
      \item Right: a \href{https://en.wikipedia.org/wiki/Lambda\_calculus}{$\lambda$ (lambda) Expression} (aka Anonymous Function). A $\lambda$ function is a function that you define and apply in a specific context, very similar to an anonymous class (in OOP) that you define and instantiate once.
      \item Returns: another array whereby every element from the input array has been passed as an argument to the $\lambda$ function.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{Transform XML to JSON}
\begin{enumerate}[resume*]
\item Create a new flow and name it \ttt{mod1-xml2json}
\item Set the input payload metadata to \ttt{src/test/resources/deltaSoapResponsesToAllDestinations.xml}, name the new type \ttt{flights\_xml}
\item Edit the sample data
\item Turn on the preview
\item change the output to \ttt{JSON}
\item Replace \ttt{\{\}} to \ttt{payload}
\item Explore the structure in the Preview and focus on the objects created with \ttt{return} fields repeating
\item Is this a valid JSON data structure?
  \newline
  \emph{
    According to the \href{https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf}{JSON specification} this is a valid JSON. But it is not appropriate.
  }
  \newline
  Transform the XML into a JSON collection containing the objects found under \ttt{return} tags
\item Use the \ttt{..*} selector to perform a recursive search and find fields named \ttt{return}
  \begin{lstlisting}
    payload..*return
  \end{lstlisting}
\item Go to the first element in the sample data under the \ttt{return} tag
\item Add another \ttt{return} tag with a simple value
\lstset{language=XML,
  morekeywords={return,10}
}
\begin{lstlisting}
  <return>
    <airlineName>Delta</airlineName>
    <code>A1B2C3</code>
    <departureDate>2018/03/20</departureDate>
    <destination>SFO</destination>
    <emptySeats>40</emptySeats>
    <origin>MUA</origin>
    <planeType>Boing 737</planeType>
    <price>400.0</price>
    <return>10</return>
  </return>
\end{lstlisting}
\item Illustrate that \ttt{..*} performs a breadth-first search and the output contains an extra result all the way to the bottom. 
\item Use the \ttt{.*} selector to perform a search at the right level--no longer do we receive the next \ttt{return} result. 
  \begin{lstlisting}
    payload.findflightResponse.*return
  \end{lstlisting}
\item Restore your sample data by removing the additional nested \ttt{<return>10</return>} XML tag.
\item Ensure you make use of the namespace from the input data.  Ignoring namespaces is not advised unless you are certain the data will always look the same, you will never have another \ttt{findFlightResponse} tag with a different meaning
  \begin{lstlisting}
    ns ns2 http://soap.training.mulesoft.com/
    ---
    payload.ns2#findFlightResponse.*return
  \end{lstlisting}
\item Copy all the data from the preview
\item Create a new file under \ttt{src/test/resources} and call it \ttt{flights.json}
\end{enumerate}

%%%%%%
\subsection{Transform JSON to XML}
\begin{enumerate}[resume*]

\item Create a new flow and name it \ttt{mod1-json2xml}
\item Drop a DW to the process area
\item Set the input payload metadata to \ttt{src/test/resources/flights.json}
\item Edit the sample data
\item Turn on the preview
\item Change the output to XML
\item Replace \ttt{\{\}} to \ttt{payload}
\item The error error says \ttt{Cannot coarse an array ... to a String}
  \begin{enumerate}
  \item The problem lies with XML not having any knowledge of arrays but just repeating elements to indicate sequences.  No other format that I know of has such semantics, other formats have knowledge and serialization of the array type.
  \item We need to proceed by eliminating the arrays
  \end{enumerate}
\item Create an appropriate XML for just two elements of the inputs
  \lstset{language=dw}
  \begin{lstlisting}
    %dw 2.0
    output application/xml
    ---
    flights: {
      flight: payload[0],
      flight: payload[1]
    }
  \end{lstlisting}
\item Set the output to \ttt{application/dw} and identify the internal data structure we must aim for when generating XML
\item We need to generate XML for all elements not just the first two, change the code so that we now iterate over the collection of data in the \ttt{payload}
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    flights: payload map {
      flight: $
    }
  \end{lstlisting}
\item Switch the output back to XML results in errors because we are still having an array in our data structure
\item Change the output yet again to \ttt{application/dw}
\item Eliminate the array by enclosing the \ttt{map} in \ttt{$\{()\}$}
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    flights: {(payload map {
      flight: $
    })}
  \end{lstlisting}
  \emph{
    The semantics of \ttt{()} are the usual precedence operators, however \textbf{the semantics of parenthesis change when they appear on their own within \ttt{$\{\}$} enclosing (i) objects or (ii) arrays of objects} to the following: \textbf{Break every single object into pairs of keys and values}. The outer \ttt{$\{\}$} are there to construct a new object from all the pairs of keys and values. Hence why we end up with single object containing all the keys and their associated values for each object in the collection.
  }
\item \emph{So far we solved this transformation by following a top-to-bottom solution.  You can also solve this transformation by following a bottom-up approach.}
  \newline
  Change the expression back to just \ttt{payload} and eliminate the array first!
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    flights: {(payload)}
  \end{lstlisting}
\item Organize the records around their own tag before we destroy the array and collapse the first level of containing objects.
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    flights: {(payload map flight: $)}
  \end{lstlisting}
  \emph{Note that objects with a single field can have the \ttt{$\{\}$} omitted}
\item Finally, change the output back to XML
  
\end{enumerate}

