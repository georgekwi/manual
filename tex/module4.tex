\chapter{Flights and Airports}

In this module we work on the main use-case of the class.  This use-case entails combining flights with airports and transforming the data such that are communicated with external systems. The tasks we shall perform are as follows:
\begin{itemize}
\item Dynamically rename fields
\item Combine data from two sources
\item Explore in more detail functional programming
\item Optimize your code in the absence of profiling tools
\item Reorder objects to meet legacy system criteria
\item Traverse and transform any type of structured data
\end{itemize}
In fact, the remainder of the class makes use of this use-case.  We shall still apply unit-testing to solve smaller issues before we integrate the unit-tested expressions in our main transformation. 

%%
%%
%%
\section{Change field names}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item Create a new Mule Configuration file and name it \ttt{mod4}
\item Create a new flow named \ttt{mod4-flights-airports}
\item Drop a DW to the process area of the flow
\item Define the payload input metadata to  \ttt{flights\_json}
\item Edit the sample data
\item Turn on the preview
\item Change the output to \ttt{application/dw}
\end{enumerate}

%%%%%%
\subsection{Create the map}
\begin{enumerate}[resume*]
\item Create a variable, \ttt{fs2fs}, that contains a map from source field names to target field names
  \begin{lstlisting}
    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }
  \end{lstlisting}
  \emph{
    I do know we can just do it in-place as part of the lambda expression of a \ttt{map} function. Creating the variable will allow to show how it can be done dynamically.  I could easily pass such a map through an HTTP request, read it from a file, etc.
  }
  \newline
  \emph{
    What we need to do is iterate over an object!
  }
\end{enumerate}

%%%%%%
\subsection{The \ttt{mapObject} function}
\begin{enumerate}[resume*]
\item Access the first object
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    
    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }
    ---
    payload[0]
  \end{lstlisting}
\item Visit the \href{https://docs.mulesoft.com/mule-runtime/4.3/dw-core-functions-mapobject}{\ttt{mapObject} documentation page} and explore its signature.  Focus on the return type of the \les{}.
\item Iterate over the object and return the empty object form the \les
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {}
  \end{lstlisting}
  \emph{
    Notice the result in the preview, it is also an empty object.  \ttt{mapObject} invokes the \les{} once for every single pair of key and value in order of appearance.  The result of \ttt{mapObject} is the concatenated objects returned from the \les.
  }
\item Reform the object
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {k: v}
  \end{lstlisting}
\item Examine the preview
  \begin{lstlisting}
    {
      k: "Delta",
      k: "A1B2C3",
      k: "2018/03/20",
      k: "SFO",
      k: "40",
      k: "MUA",
      k: "Boing 737",
      k: "400.0"
    }
  \end{lstlisting}
  \emph{
    Notice that the values are being reformed, that is the \ttt{v} is evaluated, while the keys, \ttt{k}, is displayed verbatim.
  }
\item Force the evaluation of the field name
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(k): v}
  \end{lstlisting}
  \emph{
    We must enclose the key inside \ttt{()} to force its evaluation.  It is how the language works to facilitate the creation of fields--on the one hand we don't have to make excessive use of quotes enclosing the hard-coded fields while on the other we must enclose the keys inside parenthesis when dynamically evaluating them.
  }
  \newline
  \emph{
    It is worth the effort to inspect the types of fields when using the \ttt{mapObject} function.  By enclosing the \ttt{(sizeOf(k))} you will see in the preview that fields are of a specific type \ttt{Key}.  This is a critical detail that we will latch on when working on the final exercise of the class. 
  }
\end{enumerate}

%%%%%%
\subsection{Change the field names}
\begin{enumerate}[resume*]
\item Dynamically evaluate the key based upon the \ttt{fs2rn} map for a single object
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(fs2rn[k]): v}
  \end{lstlisting}
\item Examine the error: \ttt{Cannot coerce Null (null) to Key}
  \newline
  \emph{
    The error is due to keys not appearing in the \ttt{fs2rn} map.  For example, \ttt{code}, \ttt{price}, etc.
  }
\item Accommodate for unchanged keys
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(fs2rn[k] default k): v}
  \end{lstlisting}
\item Change the field names for all objects in the array
  \begin{lstlisting}
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
  \end{lstlisting}
\end{enumerate}

%%
%%
%%
\section{Combine flights and airports}

%%%%%%
\subsection{Explore the CSV file}
\begin{enumerate}
\item Navigate under \ttt{src/main/resources} folder
\item Right click the \ttt{airportInfoTiny.csv}
\item Select \ttt{Open With} and then click \ttt{Text Editor}
\item Discuss the contents and identify bad data
  \newline
  \emph{
    Dealing with bad data now days is the norm, as such this CSV file contains bad data.  There are two instances of such bad data:
    \begin{itemize}
    \item In the header the \ttt{ ICAO} header has an empty space in the prefix
    \item Rows 7 and 13 are duplicated when this CSV file should contain unique records
    \end{itemize}
  }
\end{enumerate}


%%%%%%
\subsection{Parse the CSV airports}
\begin{enumerate}[resume*]
\item Navigate back to \ttt{mod4} mule configuration file
\item Create a new flow named \ttt{mod4-read-parse-file}
\item Drop a DW to the process area of the flow
\item Turn on the preview
\item Change the output to \ttt{application/dw}
\item Just type the function \ttt{readUrl} in the body of the expression
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl
  \end{lstlisting}
\item Explore the signature
  \begin{lstlisting}
    (first:String | Binary, second:String, third:Object) -> ???
  \end{lstlisting}
  \emph{
    The details of \ttt{readUrl} function can be found in this \href{https://docs.mulesoft.com/mule-runtime/4.3/dw-core-functions-readurl}{page}.
  }
\item Read and parse the file
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
  \end{lstlisting}
  \emph{
    The last argument, aka reader properties, is not needed because the default separator is the \ttt{,} symbol.  It is only here for illustration.  You can find all reader properties, along with the default values, in this \href{https://docs.mulesoft.com/mule-runtime/4.3/dataweave-formats-csv\#reader-properties}{documentation page}.
  }
\item Fix the duplicate records
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
    distinctBy $.IATA
  \end{lstlisting}
  \emph{
    \ttt{IATA} stands for International Air Transport Association and its values are standardized across the industry to be unique codes identifying airports.  As such we make use of just this value to create a set out the collection--i.e. get the unique values.
  }
\item Incorporate the code in the \ttt{mod4-flights-airports} flow
  \begin{lstlisting}
    %dw 2.0
    output application/dw

    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }

    var airports = readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
    distinctBy $.IATA

    ---
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
  \end{lstlisting}
\end{enumerate}

%%%%%%
\subsection{Inject the airport to each flight}
\begin{enumerate}[resume*]
\item Chain another \ttt{map} function
  \begin{lstlisting}
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
    map {
      
    }
  \end{lstlisting}
  \emph{
    There is no need for another chained \ttt{map} function, can can embed the combination of the data in a single iteration.  However, since we are in training clarity takes precedence vs performance.
  }
\item Reintroduce the fields from the previous map
  \begin{lstlisting}
    map {
      ($)
    }
  \end{lstlisting}
\item Add the \ttt{airport} field and assign to it all airports
  \begin{lstlisting}
    map {
      ($),
      airport: airports
    }
  \end{lstlisting}
\item Nest \ttt{filter} to search for the \ttt{SFO} airport
  \begin{lstlisting}
    map {
      ($),
      airport: airports filter ($.IATA == "SFO")
    }
  \end{lstlisting}
\item Dynamically make use of the flight's \ttt{destination} field to search the airports
  \begin{lstlisting}
    map {
      ($),
      airport: airports filter ($.IATA == $.destination)
    }
  \end{lstlisting}
\item Examine the output in the preview
  \begin{lstlisting}
    [
      {
        carrier: "Delta",
        code: "A1B2C3",
        date: "2018/03/20",
        destination: "SFO",
        seats: "40",
        origin: "MUA",
        plane: "Boing 737",
        price: "400.0",
        airport: []
      },
      ...
    ]
  \end{lstlisting}
  \emph{
    Notice the empty data when earlier we were displaying the SFO record.  The reason for this is because we have nested a filter right inside a map function and we choose to make use of the \ttt{\$} placeholders in both cases!
  }
\item Change \ttt{filter}'s \les{} argument names fixing the transformation
  \begin{lstlisting}
    map {
      ($),
      airport: airports filter  (e) -> (e.IATA == $.destination)
    }
  \end{lstlisting}
  \emph{
    Not only we fixed our transformation by combining each flight with an airport record we also fixed the airport record that is associated with a flight to match the flight's record \ttt{destination} field value.
  } 
\end{enumerate}

%%%%%%
\subsection{Functions as values}
\begin{enumerate}[resume*]
\item Create and apply a function that does the filtering
  \begin{lstlisting}
    var filterAirportsByIATA = (dest) -> airports filter ($.IATA == dest)
    ---
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
    map {
      ($),
      airport: filterAirportsByIATA($.destination)
    }
  \end{lstlisting}
  \emph{
    For the most part the name of this functions gives away that every single aspect is hard-coded, apart from the IATA code passed to the \ttt{dest} argument.
  }
\item Create and apply a ``naive'' generic filter function
  \begin{lstlisting}
    var filterAirportsByIATA = (dest) -> airports filter ($.IATA == dest)
    var genericFilter = (a,f,v) -> a filter ($[f] == v)
    ---
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
    map {
      ($),
      airport: genericFilter(airports,"IATA",$.destination)
    }
  \end{lstlisting}
  \emph{
    This is a naive version of a generic filter because we have hard-coded the condition!  A generic filter function should be able to take any kind of a \ttt{Boolean} condition and filter records of data.
  }
\item Rename the \ttt{genericFilter} function to \ttt{genericFilterNaive}
\item Create and apply a truly generic function
  \begin{lstlisting}
    var filterAirportsByIATA = (dest) -> airports filter ($.IATA == dest)
    var genericFilterNaive = (a,f,v) -> a filter ($[f] == v)
    var genericFilter = (a,fn) -> a filter fn($)
    ---
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
    map {
      ($),
      airport: genericFilter(airports,(airport) -> airport.IATA == $.destination)
    }
  \end{lstlisting}
  \emph{
    Those observant enough should be able to realize the \ttt{filter} function is generic enough and there is no need for yet another function.  Nonetheless, this small exercise exposes us to aspects of functional programming and give us insights on how built-in functions that accept \lep{} as arguments behave.
    \newline
    This is an example where a function is passed as an argument to yet another function.  In a very similar manner we can return a function as the return value of a function--we shall see this next.
  }
\end{enumerate}

%%%%%%
\subsection{Curried functions}
\begin{enumerate}[resume*]
\item Create a curried function
  \begin{lstlisting}
    var genericFilterC = (a) -> (fn) -> a filter fn($)
  \end{lstlisting}
  \emph{
    Nope there is no relationship to the spice, the name comes from \href{https://en.wikipedia.org/wiki/Haskell_Curry}{Haskell Brooks Curry}.  Curry invented the concept of \href{https://en.wikipedia.org/wiki/Currying}{currying}
    \newline
    There are two main reasons for creating curried functions:
    \begin{itemize}
    \item Partial application of functions when all the arguments are not present at the same time--I have yet to find a use case where this partial application of curried functions can be applied in DW
    \item Function factories where out of a single definition you can define different but related functions.  This last point is where curried functions can apply in DW. 
    \end{itemize}
  }
\item Define functions for filtering flights and airports out of the \ttt{genericFilterC} function
  \begin{lstlisting}
    var genericFilterC = (a) -> (fn) -> a filter fn($)
    var flightsFilter = genericFilterC(payload)
    var airportsFilter = genericFilterC(airports)
  \end{lstlisting}
  \emph{
    Only one of the arguments is applied to \ttt{genericFilterC} and a function is returned and stored in the corresponding variables (i.e. \ttt{flightsFilter} and \ttt{airportsFilter}).
    \newline
    Another way to visualize these two function is by illustrating what they look like:
    \begin{itemize}
    \item flightsFilter--\ttt{(fn) -> payload filter fn(\$)}
    \item airportsFilter--\ttt{(fn) -> airports filter fn(\$)}
    \end{itemize}
    \href{https://stackoverflow.com/questions/36314/what-is-currying}{This discussion} under stackoverflow could also help with your understanding.
  }
\item Apply the \ttt{airportsFilter} function
  \begin{lstlisting}
    map {
      ($),
      airport: airportsFilter((airport) -> airport.IATA == $.destination)
    }
  \end{lstlisting}
\end{enumerate}

%%%%%%
\subsection{A more efficient transformation}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Clean up the data}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%
%%
%%
\section{Reordering fields}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{pluck} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{pluck} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{reduce} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Re-ordering fields}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Integrate field re-ordering to our main use-case}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}
