\chapter{Flights and Airports}

In this module we work on the main use-case of the class.  This use-case entails combining flights with airports and transforming the data such that are communicated with external systems. The tasks we shall perform are as follows:
\begin{itemize}
\item Dynamically rename fields
\item Combine data from two sources
\item Explore in more detail functional programming
\item Optimize your code in the absence of profiling tools
\item Reorder objects to meet legacy system criteria
\item Traverse and transform any type of structured data
\end{itemize}
In fact, the remainder of the class makes use of this use-case.  We shall still apply unit-testing to solve smaller issues before we integrate the unit-tested expressions in our main transformation. 

%%
%%
%%
\section{Change field names}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item Create a new Mule Configuration file and name it \ttt{mod4}
\item Create a new flow named \ttt{mod4-flights-airports}
\item Drop a DW to the process area of the flow
\item Define the payload input metadata to  \ttt{flights\_json}
\item Edit the sample data
\item Turn on the preview
\item Change the output to \ttt{application/dw}
\end{enumerate}

%%%%%%
\subsection{Create the map}
\begin{enumerate}[resume*]
\item Create a variable, \ttt{fs2fs}, that contains a map from source field names to target field names
  \begin{lstlisting}
    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }
  \end{lstlisting}
  \emph{
    I do know we can just do it in-place as part of the lambda expression of a \ttt{map} function. Creating the variable will allow to show how it can be done dynamically.  I could easily pass such a map through an HTTP request, read it from a file, etc.
  }
  \newline
  \emph{
    What we need to do is iterate over an object!
  }
\end{enumerate}

%%%%%%
\subsection{The \ttt{mapObject} function}
\begin{enumerate}[resume*]
\item Access the first object
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    
    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }
    ---
    payload[0]
  \end{lstlisting}
\item Visit the \href{https://docs.mulesoft.com/mule-runtime/4.3/dw-core-functions-mapobject}{\ttt{mapObject} documentation page} and explore its signature.  Focus on the return type of the \les{}.
\item Iterate over the object and return the empty object form the \les
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {}
  \end{lstlisting}
  \emph{
    Notice the result in the preview, it is also an empty object.  \ttt{mapObject} invokes the \les{} once for every single pair of key and value in order of appearance.  The result of \ttt{mapObject} is the concatenated objects returned from the \les.
  }
\item Reform the object
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {k: v}
  \end{lstlisting}
\item Examine the preview
  \begin{lstlisting}
    {
      k: "Delta",
      k: "A1B2C3",
      k: "2018/03/20",
      k: "SFO",
      k: "40",
      k: "MUA",
      k: "Boing 737",
      k: "400.0"
    }
  \end{lstlisting}
  \emph{
    Notice that the values are being reformed, that is the \ttt{v} is evaluated, while the keys, \ttt{k}, is displayed verbatim.
  }
\item Force the evaluation of the field name
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(k): v}
  \end{lstlisting}
  \emph{
    We must enclose the key inside \ttt{()} to force its evaluation.  It is how the language works to facilitate the creation of fields--on the one hand we don't have to make excessive use of quotes enclosing the hard-coded fields while on the other we must enclose the keys inside parenthesis when dynamically evaluating them.
  }
  \newline
  \emph{
    It is worth the effort to inspect the types of fields when using the \ttt{mapObject} function.  By enclosing the \ttt{(sizeOf(k))} you will see in the preview that fields are of a specific type \ttt{Key}.  This is a critical detail that we will latch on when working on the final exercise of the class. 
  }
\end{enumerate}

%%%%%%
\subsection{Change the field names}
\begin{enumerate}[resume*]
\item Dynamically evaluate the key based upon the \ttt{fs2rn} map for a single object
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(fs2rn[k]): v}
  \end{lstlisting}
\item Examine the error: \ttt{Cannot coerce Null (null) to Key}
  \newline
  \emph{
    The error is due to keys not appearing in the \ttt{fs2rn} map.  For example, \ttt{code}, \ttt{price}, etc.
  }
\item Accommodate for unchanged keys
  \begin{lstlisting}
    payload[0] mapObject (v,k,i) -> {(fs2rn[k] default k): v}
  \end{lstlisting}
\item Change the field names for all objects in the array
  \begin{lstlisting}
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
  \end{lstlisting}
\end{enumerate}

%%
%%
%%
\section{Combine flights and airports}

%%%%%%
\subsection{Explore the CSV file}
\begin{enumerate}
\item Navigate under \ttt{src/main/resources} folder
\item Right click the \ttt{airportInfoTiny.csv}
\item Select \ttt{Open With} and then click \ttt{Text Editor}
\item Discuss the contents and identify bad data
  \newline
  \emph{
    Dealing with bad data now days is the norm, as such this CSV file contains bad data.  There are two instances of such bad data:
    \begin{itemize}
    \item In the header the \ttt{ ICAO} header has an empty space in the prefix
    \item Rows 7 and 13 are duplicated when this CSV file should contain unique records
    \end{itemize}
  }
\end{enumerate}


%%%%%%
\subsection{Parse the CSV airports}
\begin{enumerate}[resume*]
\item Navigate back to \ttt{mod4} mule configuration file
\item Create a new flow named \ttt{mod4-read-parse-file}
\item Drop a DW to the process area of the flow
\item Turn on the preview
\item Change the output to \ttt{application/dw}
\item Just type the function \ttt{readUrl} in the body of the expression
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl
  \end{lstlisting}
\item Explore the signature
  \begin{lstlisting}
    (first:String | Binary, second:String, third:Object) -> ???
  \end{lstlisting}
  \emph{
    The details of \ttt{readUrl} function can be found in this \href{https://docs.mulesoft.com/mule-runtime/4.3/dw-core-functions-readurl}{page}.
  }
\item Read and parse the file
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
  \end{lstlisting}
  \emph{
    The last argument, aka reader properties, is not needed because the default separator is the \ttt{,} symbol.  It is only here for illustration.  You can find all reader properties, along with the default values, in this \href{https://docs.mulesoft.com/mule-runtime/4.3/dataweave-formats-csv\#reader-properties}{documentation page}.
  }
\item Fix the duplicate records
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    ---
    readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
    distinctBy $.IATA
  \end{lstlisting}
  \emph{
    \ttt{IATA} stands for Internation Air Transport Association and its values are standardized across the industry to be unique codes identifying airports.  As such we make use of just this value to create a set out the collection--i.e. get the unique values.
  }
\item Incorporate the code in the \ttt{mod4-flights-airports} flow
  \begin{lstlisting}
    %dw 2.0
    output application/dw

    var fs2rn = {
      airlineName: "carrier",
      departureDate: "date",
      emptySeats: "seats",
      planeType: "plane"
    }

    var airports = readUrl(
      "classpath://airportInfoTiny.csv",
      "application/csv",
      {
        separator: ","
      }
    )
    distinctBy $.IATA

    ---
    payload map (
      $ mapObject (v,k,i) -> {(fs2rn[k] default k): v}
    )
  \end{lstlisting}
\end{enumerate}

%%%%%%
\subsection{Inject the airport to each flight}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Functions as values}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Curried functions}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{A more efficient transformation}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Clean up the data}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%
%%
%%
\section{Reordering fields}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{pluck} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{pluck} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{The \ttt{reduce} function}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Re-ordering fields}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}

%%%%%%
\subsection{Integrate field re-ordering to our main use-case}
\begin{enumerate}[resume*]
\item ...
\end{enumerate}
