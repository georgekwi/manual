\chapter{Variables, Functions, Modules}

%%
%%
%%
\section{Organize DataWeave code with variables and functions}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item Create a new Mule Configuration file and name it \texttt{mod2}, it will contain the solutions to all WTs from module 2.
\item Create a new flow named \texttt{mod2-functions}
\item Define the payload input metadata to the flights\_xml
\item Edit the sample data
\item Turn on the preview
\item Change the output to \texttt{application/dw}
\item Change the body of the expression to \texttt{payload..*return}
\end{enumerate}

%%%%%%
\subsection{Create a variable}
\begin{enumerate}[resume*]
\item Create a variable visible throughout the DW expression
  \begin{lstlisting}
    var theTotalSeats = 400
  \end{lstlisting}
\item Add the \texttt{totalSeats} field to the existing list of objects, do it for a single object then do it for all objects in the collection
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return[0] ++ {
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
\item Do it now for all elements
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map ($ ++ {
      totalSeats: theTotalSeats
    })
  \end{lstlisting}
  \emph{
    \texttt{++} we have already seen when concatenating strings we see it operating with objects as well because it is overloaded, more on overloading soon.
  }
\item There is another way to add a field(s) to an existing object
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map {
      ($)
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
  \emph{
    We have already seen $\{()\}$ when eliminating arrays, here these $()$ are applied to single objects with the same effect; i.e. destroy the object and retrieve the basic building blocks of the object, that is the keys and the associated values.  These basic building blocks are then introduced in the new object created by the outermost object.}
  \newline
  \emph{
    Pick the method you prefer to concatenate objects, I prefer the latter which is the one I shall be using for the duration of this class.
  }
\end{enumerate}

%%%%%%
\subsection{Calculate the total seats as a function of the \texttt{planeType} using \texttt{fun}}
\begin{enumerate}[resume*]
\item Create and apply a function and start unit-testing it
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
  \emph{
    \texttt{pt} is a user defined arbitrary name, denoting the sole input parameter
  }
  \newline
  \emph{
    By unit testing we refer to the method by which small chunks of our functionality is tested before we put them all together.  We are not referring to automated/regression testing.
  }
\item Create the condition that identifies 737s over the other types of planes
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt contains "737"
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Enclose the confition in an \texttt{if} expression
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737"
    ) 150 else 300
    ---
    payload..*return map {
      ($)
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Change the function expression to allow for the 727 and 707 to be set to 150 seats
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737" or
      pt contains "707" or
      pt contains "727"
    ) 150 else 300
  \end{lstlisting}
\item Fix the error \texttt{Cannot coerce String (737) to Boolean}
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      (pt contains "737") or
      (pt contains "707") or
      (pt contains "727")
    ) 150 else 300
  \end{lstlisting}
  \emph{
    Parenthesization to enforce precedence is required in this context because \texttt{or} has higher precedence vs \texttt{contains}
  }
  \emph{
    A chunk of the issues you will have when you start writing DW expressions on your own will stem from precedence rules.
  }
\item Discuss issues with the \texttt{getTotalSeats} functions
  \begin{enumerate}
  \item We execute this function once per record
  \item We are searching strings
  \item We do this string search three times
  \item The function is not that efficient, we could do better
  \end{enumerate}
\end{enumerate}

%%%%%%
\subsection{Calculate efficiently the total seats as a function of \texttt{planeType} using a $\lambda$ expression}
\begin{enumerate}[resume*]
\item
\end{enumerate}

%%
%%
%%
\section{Reuse DataWeave transformations}

%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%


%%
%%
%%
\section{Create and use DataWeave modules}

%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
