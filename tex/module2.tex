\chapter{Variables, Functions, Modules}

%%
%%
%%
\section{Organize and Reuse DataWeave code}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item Create a new Mule Configuration file and name it \ttt{mod2}, it will contain the solutions to all WTs from module 2.
\item Create a new flow named \ttt{mod2-functions}
\item Define the payload input metadata to the flights\_xml
\item Edit the sample data
\item Turn on the preview
\item Change the output to \ttt{application/dw}
\item Change the body of the expression to \ttt{payload..*return}
\end{enumerate}

%%%%%%
\subsection{Create a variable}
\begin{enumerate}[resume*]
\item Create a variable visible throughout the DW expression
  \begin{lstlisting}
    var theTotalSeats = 400
  \end{lstlisting}
\item Add the \ttt{totalSeats} field to the existing list of objects, do it for a single object then do it for all objects in the collection
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return[0] ++ {
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
\item Do it now for all elements
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map ($ ++ {
      totalSeats: theTotalSeats
    })
  \end{lstlisting}
  \emph{
    \ttt{++} we have already seen when concatenating strings we see it operating with objects as well because it is overloaded, more on overloading soon.
  }
\item There is another way to add a field(s) to an existing object
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map {
      ($)
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
  \emph{
    We have already seen $\{()\}$ when eliminating arrays, here these $()$ are applied to single objects with the same effect; i.e. destroy the object and retrieve the basic building blocks of the object, that is the keys and the associated values.  These basic building blocks are then introduced in the new object created by the outermost object.}
  \newline
  \emph{
    Pick the method you prefer to concatenate objects, I prefer the latter which is the one I shall be using for the duration of this class.
  }
\end{enumerate}

%%%%%%
\subsection{Calculate the total seats as a function of the \ttt{planeType} using \ttt{fun}}
\begin{enumerate}[resume*]
\item Create and apply a function and start unit-testing it
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
  \emph{
    \ttt{pt} is a user defined arbitrary name, denoting the sole input parameter
  }
  \newline
  \emph{
    By unit testing we refer to the method by which small chunks of our functionality is tested before we put them all together.  We are not referring to automated/regression testing.
  }
\item Create the condition that identifies 737s over the other types of planes
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt contains "737"
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Enclose the confition in an \ttt{if} expression
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737"
    ) 150 else 300
    ---
    payload..*return map {
      ($)
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Change the function expression to allow for the 727 and 707 to be set to 150 seats
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737" or
      pt contains "707" or
      pt contains "727"
    ) 150 else 300
  \end{lstlisting}
\item Fix the error \ttt{Cannot coerce String (737) to Boolean}
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      (pt contains "737") or
      (pt contains "707") or
      (pt contains "727")
    ) 150 else 300
  \end{lstlisting}
  \emph{
    Parenthesization to enforce precedence is required in this context because \ttt{or} has higher precedence vs \ttt{contains}
  }
  \emph{
    A chunk of the issues you will have when you start writing DW expressions on your own will stem from precedence rules.
  }
\item Discuss issues with the \ttt{getTotalSeats} functions
  \begin{enumerate}
  \item We execute this function once per record
  \item We are searching strings
  \item We do this string search three times
  \item The function is not that efficient, we could do better
  \end{enumerate}
  \emph{
    Please do not think for a moment that in modern computing string searches as slow, they are fast and could
    be optimized in a number of ways.  Nonetheless, this discussion has merit in the presence of large to very
    large data sets where the function is called once per record; i.e. every little bit helps!
  }
\end{enumerate}

%%%%%%
\subsection{Calculate efficiently the total seats as a function of \ttt{planeType} using a lambda expression}
\begin{enumerate}[resume*]
\item Create another function named \ttt{getTotalSeatsL}
  \begin{lstlisting}
    var getTotalSeatsL = (pt) -> pt
  \end{lstlisting}
  \emph{
    L stands for Lambda, we store an anonymous function to a variable; i.e. we provide this anonymous function
    with a name.  Additionaly, the body of this function evaluates into the argument we passed--this encourages
    unit testing.
  }
\item Apply the function to in the expression and get results
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType)
    }
  \end{lstlisting}
  \emph{
    Applying the function as soon as possible and getting results as we further develop our function
    will only facilitate unit testing and code correctness.
  }
\item Get the last three characters of the plane type
  \begin{lstlisting}
    var getTotalSeatsL = (pt) -> pt[-3 to -1] as Number
  \end{lstlisting}
  \emph{
    We can now use the number to compare instead of doing a string search which will speed up the execution of
    our code.
  }
\item Introduce closures (i.e. localized declarations) using \ttt{do \{\}}
  \begin{lstlisting}
    var getTotalSeatsL = pt -> do {
      var pn = pt[-3 to -1] as Number
      ---
      pn
    }
  \end{lstlisting}
  \emph{
    A \href{https://en.wikipedia.org/wiki/Closure_(computer_programming)}{closure} is a construct that allows for
    the declaration of variables, functions, etc with a localized scope.  The \ttt{---} serve the same purpose
    like the \ttt{---} we see in other DW expressions, they are section separators used to separate the
    declarations and the expression.
  }
\item Add the conditional to the function
  \begin{lstlisting}
    var getTotalSeatsL = pt -> do {
      var pn = pt[-3 to -1] as Number
      ---
      if (pn == 737 or pn == 707 or pn ==727) 150 else 300
    }    
  \end{lstlisting}
  \emph{
    You can use either one of these two functions to calculate the total seats; however, if you would like to use
    features such as function overloading you MUST stick with the \ttt{fun}.
  }
\end{enumerate}

%%%%%%
\subsection{Adjust price for currency}
\begin{enumerate}[resume*]
\item Create an object that contains currency exhcange rates
  \begin{lstlisting}
    var xes = {
      USD: 1.0,
      EUR: 0.9,
      GBP: 0.8,
      CAD: 1.3,
      AUD: 1.5,
      MXN: 25,
      INR: 72
    }
  \end{lstlisting}
  \emph{
    We hardcode these currencies because we are within the confines of training.  We can easily fetch these
    currencies dynamically from any data source and generate the map.
  }
\item Create a function to calculate the price for a currency
  \begin{lstlisting}
    var adjustFor = (p,c) -> p * xes[c]
  \end{lstlisting}
\item Apply the function in prefix syntax
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price,"EUR")
    }
  \end{lstlisting}
\item Apply the function in infix syntax
  \begin{lstlisting}
    payload..*return map { ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price,"EUR"),
      priceGBP: $.price adjustFor "GBP"
    }    
  \end{lstlisting}
  \emph{
    Functions with exactly two arguments get this infix application support!  In fact, infix function
    application is encouraged because (1) it is natural in its application, (2) no need to use excessive
    parenthesis, and (3) allows for a more natural application of expression chains.
  }
\end{enumerate}

%%
%%
%%
\section{Reuse DataWeave transformations}

%%%%%%
\subsection{Store DW code in a file}
\begin{enumerate}
\item Switch to the XML view of your file
\item Navigate under the \lstinline!mod2-functions! flow and illustrate how the code is inline
\item Switch back to the graphical view (aka Message Flow)
\item Go to the properties of the DW processor under the \lstinline!mod2-functions!
\item Click the Edit current target button (pencil icon)
\item Click the radio button File and type \lstinline!dw/transforms/mod2/functions! in the text field to the right
\item Click OK
  \emph {
    From the point of view of the DW properties UI nothing has changed.  Nonetheless, with this action we have
    stored the DW code inside a new file under \lstinline!src/main/resources/dw/transforms/mod2! named
    \lstinline!functions.dwl!
  }
\end{enumerate}

%%%%%%
\subsection{Reuse the DW code from the file}
\begin{enumerate}[resume*]
\item Create a new flow named \lstinline!mod2-reuse!
\item Drop a DW to the process area of the flow
\item Switch to the XML view
\item Locate the DW you just created
\item Remove the \lstinline!CDATA! tag
  \begin{lstlisting}
    <![CDATA[%dw 2.0 output application/java --- {}]]>
  \end{lstlisting}
\item Introduce the \ttt{/} closing to the opening \ttt{<ee:set-payload />} tag, this should automatecally remove the explicit closing tag
\item Add the attribute \ttt{resource} to the \ttt{<ee:set-payload />} tag
  \begin{lstlisting}
    <ee:set-payload resource="dw/transforms/mod2/functions.dwl" />
  \end{lstlisting}
  \emph{
    This is the only way you could reuse the full trandormation, i.e. by modifying the XML.  Had you gone inside
    the UI and attempt to reuse the file, you would be overwiting it!  That pencil button is a "one way trip",
    only there to store the file not reference it.
  }
\item Switch back to the graphical view
\item Open the properties of the the DW processor under the \ttt{mod2-reuse}
\item Turn on the Preview
  \emph{
    There is an issue that indicates that there is no metadata identifying what the payload is.  You can fix
    this issue by just setting the metadata again.  This issue is displayed because of DataSense.  This isssue
    is only visible when in Studio, if we start the server and deploy our app, DataSense is never in play. 
  }
\item Set the input payload metadata to \ttt{flights\_xml}
\item Turn on the Preview and validate you see the result
\end{enumerate}


%%
%%
%%

\section{Create and use DataWeave modules}


%%%%%%
\subsection{Create a DW module}
\begin{enumerate}
\item Create a new folder(s) under \ttt{src/main/resources}
\item In the text field type \ttt{dw/modules}
\item Create a new file under \ttt{dw.modules} and name it \ttt{Currency.dwl}
\item Type on line 1
  \begin{lstlisting}
    %dw 2.0
  \end{lstlisting}
  \emph{
    DW modules can only contain declarations.  Declarations such as variables, function, types, etc.
  }
\item Navigate back to the DW processor under \ttt{mod2-reuse}
\item Copy the \ttt{xes} variable and the \ttt{adjustFor} function
\item Paste to \ttt{Currency.dwl} under line 1 and save
\end{enumerate}

%%%%%%
\subsection{Use the module}
\begin{enumerate}[resume*]
\item Go back to the DW processor under \ttt{mod2-reuse}
\item Use the module by fully qualifying the function to adjust the price for the CAD currency
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price, "EUR"),
      priceGBP: $.price adjustFor "GBP",
      priceCAD: $.price dw::modules::Currency::adjustFor "CAD"
    }    
  \end{lstlisting}
\item Import the new module below the output directive
  \begin{lstlisting}
    import dw::modules::Currency
  \end{lstlisting}
\item Use the module again this time by taking advantage of the \ttt{import} to adjust the price for AUD
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price, "EUR"),
      priceGBP: $.price adjustFor "GBP",
      priceAUD: $.price Currency::adjustFor "AUD"
    }      
  \end{lstlisting}
\item Import the module again and provide an an alias to the module
  \begin{lstlisting}
    import dw::modules::Currency as Curr
  \end{lstlisting}
\item Use the module through the \ttt{Curr} alias next
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price, "EUR"),
      priceGBP: $.price adjustFor "GBP",
      priceAUD: $.price Currency::adjustFor "AUD",
      priceMXN: $.price Curr::adjustFor "MXN"
    }
  \end{lstlisting}
\item Import all declarations to the current namespace
  \begin{lstlisting}
    import * from dw::modules::Currency
  \end{lstlisting}
\item Use directly the \ttt{adjustFor} function
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price, "EUR"),
      priceGBP: $.price adjustFor "GBP",
      priceAUD: $.price Currency::adjustFor "AUD",
      priceMXN: $.price Curr::adjustFor "MXN",
      priceINR: $.price adjustFor "INR"
    }
  \end{lstlisting}
  \emph{
    There is also an inline version of the \ttt{adjustFor} function which takes precedence.
    As such we are not using the function provided by the module.  We can very easily
    verify by changing the body of the inline function, just change the body to 1000.
  }
\item Modify the last \ttt{import} to selectively import declarations and provide them with aliases
  \begin{lstlisting}
    import adjustFor as adj4 from dw::modules::Currency
  \end{lstlisting}
\item Use the \ttt{adj4} alias
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType),
      priceEUR: adjustFor($.price, "EUR"),
      priceGBP: $.price adjustFor "GBP",
      priceAUD: $.price Currency::adjustFor "AUD",
      priceMXN: $.price Curr::adjustFor "MXN",
      priceINR: $.price adj4 "INR"
    }
  \end{lstlisting}
\end{enumerate}  

%%%%%%
%%%%%%
%%%%%%
%%%%%%
