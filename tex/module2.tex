\chapter{Variables, Functions, Modules}

%%
%%
%%
\section{Organize DataWeave code with variables and functions}

%%%%%%
\subsection{Create a new flow}
\begin{enumerate}
\item Create a new Mule Configuration file and name it \texttt{mod2}, it will contain the solutions to all WTs from module 2.
\item Create a new flow named \texttt{mod2-functions}
\item Define the payload input metadata to the flights\_xml
\item Edit the sample data
\item Turn on the preview
\item Change the output to \texttt{application/dw}
\item Change the body of the expression to \texttt{payload..*return}
\end{enumerate}

%%%%%%
\subsection{Create a variable}
\begin{enumerate}[resume*]
\item Create a variable visible throughout the DW expression
  \begin{lstlisting}
    var theTotalSeats = 400
  \end{lstlisting}
\item Add the \texttt{totalSeats} field to the existing list of objects, do it for a single object then do it for all objects in the collection
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return[0] ++ {
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
\item Do it now for all elements
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map ($ ++ {
      totalSeats: theTotalSeats
    })
  \end{lstlisting}
  \emph{
    \texttt{++} we have already seen when concatenating strings we see it operating with objects as well because it is overloaded, more on overloading soon.
  }
\item There is another way to add a field(s) to an existing object
  \begin{lstlisting}
    %dw 2.0
    output application/json
    var theTotalSeats = 400
    ---
    payload..*return map {
      ($)
      totalSeats: theTotalSeats
    }
  \end{lstlisting}
  \emph{
    We have already seen $\{()\}$ when eliminating arrays, here these $()$ are applied to single objects with the same effect; i.e. destroy the object and retrieve the basic building blocks of the object, that is the keys and the associated values.  These basic building blocks are then introduced in the new object created by the outermost object.}
  \newline
  \emph{
    Pick the method you prefer to concatenate objects, I prefer the latter which is the one I shall be using for the duration of this class.
  }
\end{enumerate}

%%%%%%
\subsection{Calculate the total seats as a function of the \texttt{planeType} using \texttt{fun}}
\begin{enumerate}[resume*]
\item Create and apply a function and start unit-testing it
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
  \emph{
    \texttt{pt} is a user defined arbitrary name, denoting the sole input parameter
  }
  \newline
  \emph{
    By unit testing we refer to the method by which small chunks of our functionality is tested before we put them all together.  We are not referring to automated/regression testing.
  }
\item Create the condition that identifies 737s over the other types of planes
  \begin{lstlisting}
    %dw 2.0
    output application/dw
    var theTotalSeats = 400
    fun getTotalSeats(pt) = pt contains "737"
    ---
    payload..*return map {
      ($),
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Enclose the confition in an \texttt{if} expression
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737"
    ) 150 else 300
    ---
    payload..*return map {
      ($)
      totalSeats: getTotalSeats($.planeType)
    }
  \end{lstlisting}
\item Change the function expression to allow for the 727 and 707 to be set to 150 seats
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      pt contains "737" or
      pt contains "707" or
      pt contains "727"
    ) 150 else 300
  \end{lstlisting}
\item Fix the error \texttt{Cannot coerce String (737) to Boolean}
  \begin{lstlisting}
    fun getTotalSeats(pt) = if (
      (pt contains "737") or
      (pt contains "707") or
      (pt contains "727")
    ) 150 else 300
  \end{lstlisting}
  \emph{
    Parenthesization to enforce precedence is required in this context because \texttt{or} has higher precedence vs \texttt{contains}
  }
  \emph{
    A chunk of the issues you will have when you start writing DW expressions on your own will stem from precedence rules.
  }
\item Discuss issues with the \texttt{getTotalSeats} functions
  \begin{enumerate}
  \item We execute this function once per record
  \item We are searching strings
  \item We do this string search three times
  \item The function is not that efficient, we could do better
  \end{enumerate}
  \emph{
    Please do not think for a moment that in modern computing string searches as slow, they are fast and could
    be optimized in a number of ways.  Nonetheless, this discussion has merit in the presence of large to very
    large data sets where the function is called once per record; i.e. every little bit helps!
  }
\end{enumerate}

%%%%%%
\subsection{Calculate efficiently the total seats as a function of \texttt{planeType} using a $\lambda$ expression}
\begin{enumerate}[resume*]
\item Create another function named \texttt{getTotalSeatsL}
  \begin{lstlisting}
    var getTotalSeatsL = (pt) -> pt
  \end{lstlisting}
  \emph{
    L stands for Lambda, we store an anonymous function to a variable; i.e. we provide this anonymous function
    with a name.  Additionaly, the body of this function evaluates into the argument we passed--this encourages
    unit testing.
  }
\item Apply the function to in the expression and get results
  \begin{lstlisting}
    payload..*return map {
      ($),
      totalSeats: getTotalSeatsL($.planeType)
    }
  \end{lstlisting}
  \emph{
    Applying the function as soon as possible and getting results as we further develop our function
    will only facilitate unit testing and code correctness.
  }
\item Get the last three characters of the plane type
  \begin{lstlisting}
    var getTotalSeatsL = (pt) -> pt[-3 to -1] as Number
  \end{lstlisting}
  \emph{
    We can now use the number to compare instead of doing a string search which will speed up the execution of
    our code.
  }
\item Introduce closures (i.e. localized declarations) using \texttt{do \{\}}
  \begin{lstlisting}
    var getTotalSeatsL = pt -> do {
      var pn = pt[-3 to -1] as Number
      ---
      pn
    }
  \end{lstlisting}
  \emph{
    A \href{https://en.wikipedia.org/wiki/Closure_(computer_programming)}{closure} is a construct that allows for
    the declaration of variables, functions, etc with a localized scope.  The \texttt{---} serve the same purpose
    like the \texttt{---} we see in other DW expressions, they are section separators used to separate the
    declarations and the expression.
  }
\item Add the conditional to the function
  \begin{lstlisting}
    var getTotalSeatsL = pt -> do {
      var pn = pt[-3 to -1] as Number
      ---
      if (pn == 737 or pn == 707 or pn ==727) 150 else 300
    }    
  \end{lstlisting}
  \emph{
    You can use either one of these two functions to calculate the total seats; however, if you would like to use
    features such as function overloading you MUST stick with the \texttt{fun}.
  }
\end{enumerate}

%%%%%%
\subsection{Adjust price for currency}
\begin{enumerate}[resume*]
\item 
\end{enumerate}

%%%%%%
%%%%%%
%%%%%%
%%%%%%


%%
%%
%%
\section{Reuse DataWeave transformations}

%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%


%%
%%
%%
\section{Create and use DataWeave modules}

%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
%%%%%%
